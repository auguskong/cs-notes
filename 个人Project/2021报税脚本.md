## 我的需求

* 从1099 PDF文件中读取每一行的数据 需要支持多页扫描

* 过滤筛选被标记为Wash Sale的所有交易记录

* 将找到的交易记录自动用脚本添加到8949表单PDF中



## 前期准备

### 思路

#### 数据提取

* 先将PDF 转为 CSV 从CSV中读取数据 
  * ❌ 在转换过程中容易出现格式错乱的问题 
* 使用`pdfminder`来直接读取PDF中的表格 
  * ❌ 没有办法解决非标准Table的读取
* 另一个思路是先把PDF转成图片 然后用OpenCV进行表格数据的提取 详情: https://stackoverflow.com/questions/47533875/how-to-extract-table-as-text-from-the-pdf-using-python

  * ❌ 转换成图片再处理显得有点多余

* 使用OCR
  * ✅ 最后找到了一个类似OCR的解决方案 使用TrapRange针对每个页面特定坐标位置上的元素进行提取

#### 自动化表格数据填写

* pyautogui 库 自动操作鼠标键盘
* 根据格式化的数据来生成PDF文件



### 尝试过的Library

* PyPDF2 是读取Text 或者基本的PDF文件操作 分隔、合并、转换

  Documentation: 

  https://pythonhosted.org/PyPDF2/index.html

* PyPDF2的一些基本操作

  https://automatetheboringstuff.com/chapter13/

* OCRmyPDF: 将PDF 转换成可以搜索的

  https://github.com/jbarlow83/OCRmyPDF

* pdfminder: 能提取简单信息

  https://github.com/pdfminer/pdfminer.six 

  https://pdfminersix.readthedocs.io/en/latest/index.html

### Python基本操作:

1. 文件导入 文件内容提取
2. 文件写入 
4. 文件的导出
4. DataFrame的处理
   1. 列的增加/删除 
   2. 数据筛选 / 整理 e.g 单列求和 N个元素求和 
   3. 数据格式的转换 dataframe -> dict / string -> float 



### 最后确定的解决方案

TrapRange:  直接从页面截取特定坐标的元素算法  

https://github.com/thoqbk/traprange

原理介绍文章: https://dzone.com/articles/traprange-method-extract-table





## Research

pdfminer: https://pdfminer-docs.readthedocs.io/programming.html



pdfminer class relationship

![image-20210321130214577](/Users/xiangyu/Library/Application Support/typora-user-images/image-20210321130214577.png)



* `PDFParser`: fetch data from a filie
* `PDFDocument`: store data
* `PDFPageInterpreter`: process the page contents
* `PDFDevice`: translate page contents
* `PDFResourceManger`: store shared resources such as fonts or images



Layout Representation

![image-20210321130044962](/Users/xiangyu/Library/Application Support/typora-user-images/image-20210321130044962.png)



PDF is more like a graphic representation. In most cases, it has no logical structure such as sentences or paragraphs and it cannot adapt itself when the paper size changes.



pdfquery: https://github.com/jcushman/pdfquery



---



## 代码设计



整体的框架借鉴了https://github.com/thoqbk/traprange 



### traprange 源码分析整理



**Q & A**

* 为什么要先提取characters  -> rows -> texts ? 

* 用什么算法来找到每一行? 

* TextBox 可以用数学公式来进行计算和拆分吗?  e.g. 每相邻9个box 是同一行的? 
* 最后能够直接提取出来每一行的信息 但是有的时候 various 是单独在一个List当中 有的时候不是 这是为什么呢? 

* 过滤已经存在的数据是用哪个function ?

  * 根本不需要function 直接使用if语句做筛选即可

  同时还需要过滤掉 Total的  作为过滤条件的选项: 

  * List 的长度 `len(texts[34]) == 8`
  * 正则表达式 
  * 是否包单个的`W` 字符



### 根据个人需求定制



1. 单页面信息提取: 使用trapRange
   * 识别信息
   * 提取 & 过滤
     * 直接remove不需要的Total 行 
     * 筛选所有的washsale
     * 1099表格的顺序和8949不匹配 需要进行调整 
   * 存储

2. 多页面提取

   * 取 现在要把所有页面的都取出来

   * 先搞定单页面提取 然后再加一个for loop 对于其他页面进行循环即可

     `page_layouts` contains all information 

     loop through every page to extract information 

     

3. 数据写入到8949 Form

   * 将数据提取到dataframe 如何取出来已经拿到的data?

     https://stackoverflow.com/a/11287278

     ```python
     # 提取已经存在的特定column
     df1 = df[['a', 'b']]
     ```

   * 实现copy & paste 

   * 如何让`pyautogui` 使用dataframe中的数据?

   * 如何定位元素坐标?

     * 使用Mac自带的截图工具来定位 每个位置坐标

   * 如何copy paste data ? 

     * 结合 `pyperclip` 先把数据放到剪切板 然后从剪切板里面 paste

       ```python
       pyperclip.copy('abc') # replace 'abc' 
       pyautogui.hotkey('command', 'v')
       ```

4. 对每14行(8949单个表格的总行数)的数据进行求和操作

   * 需要进行type的转换 然后再进行乘除计算

   * 处理1,000 -> 1000 将所有的`,` 进行替换操作

   * 对于每14行数据进行求和操作

     ```python
     dp_no_comma.groupby(dp_no_comma.index // N).sum(level=0)
     ```

     



---



## Debug

 

* `ERROR: Could not find a version that satisfies the requirement requirements.txt (from versions: none)`

  Resolve: 需要使用`-r`来表示我们是从一个 requirement file 中安装 `pip install -r requirements.txt` 

```
-r, --requirement <file>    Install from the given requirements file. This option can be used multiple times.
```

* `df.append()` 会return 一个新的object, 所以必须用新的变量来catch一下，不然就一直是empty

* 需要disable vimium chrome extension 来启用Jupyter Notebook 的快捷键

* `/Users/xiangyu/.vimrc:1: command not found: syntax`

  Resolve: 在command line 里面source vimrc 会有问题 需要在vim中通过 `:source ~/.vimrc` 来避免

* 出现鼠标自动拖动过程中点错位置 -> 因为运行的太快了 导致出现了冲突, 使用`time.sleep()`

* 将dataframe直接导出会报错, 需要先转换成dict类型

```python
>>> df = pd.DataFrame([[1,2,3],[3,4,5]])
>>> lol = df.values.tolist()
>>> lol
[[1L, 2L, 3L], [3L, 4L, 5L]]
```

* `local variable 'curr_row_index' referenced before assignment`

已经定义了 `curr_row_index = 0`  为什么还是会报错呢? 

Resolve: 因为Python是在默认的function 内部来寻找 在function在内部是优先使用local variable的

https://stackoverflow.com/a/17506974

Due to this line `count +=1` python thinks that `count` is a local variable and will not search the global scope when you used `if count == 3:`. That's why you got that error.

Use `global` statement to handle that:

```py
def three_upper(s): #check for 3 upper letter
    global count
    for i in s:
```

From [docs](http://docs.python.org/release/1.5.1p1/tut/functions.html):

> All variable assignments in a function store the value in the local symbol table; whereas variable references first look in the local symbol table, then in the global symbol table, and then in the table of built-in names. Thus, global variables cannot be directly assigned a value within a function (unless named in a global statement), although they may be referenced.







### Vim 技巧

* 在vim 中不关闭文件直接运行python程序

https://stackoverflow.com/a/52186237

```py
! clear; python %
```

[![enter image description here](https://i.stack.imgur.com/MJBGZ.gif)](https://i.stack.imgur.com/MJBGZ.gif)



> `!` allows you to run a terminal command
>
> `clear` will empty your terminal screen
>
> `;` ends the first command, allowing you to introduce a second command
>
> `python` will use python to run your script (it could be replaced with `ruby` for example)
>
> `%` concats the current filename, passing it as a parameter to the `python` command



* 在vim中复制文本到剪切板

  ```
  先用visual模式选择要copy的所有文本 然后 "+y
  
  会在vim的最底下 显示 `xx lines yanked into "+` 表示成功复制到buffer当中
  ```

  

  



### Python 语法

* 如何将dataframe数据转换成dictionary 来方便提取 

  * https://stackoverflow.com/a/26716774

  ```python
  df.to_dict('records')
  # 生成了一个list of dicts 
  
  >>> df.to_dict('records')
  [{'a': 'red', 'b': 0.5}, 
   {'a': 'yellow', 'b': 0.25}, 
   {'a': 'blue', 'b': 0.125}]
  ```

* 如何在for loop 中拿到当前元素的index -> 使用`enumerate()`

```python
for idx, val in enumerate(ints):
	print(idx, val) # get index and value
```

* 删除dataframe中的一个column 

  ```python
  del df_clean['abc']
  ```

* 将dataframe转换成dict

  ```python
  dict_data = df.to_dict('records')
  ```

  



## Change Log

​	

3.28

* 需要将全部的data都复制粘贴到PDF
* 实现了自动填表功能

3.27 

* 完成多个页面的信息提取
* 通过使用`pyautogui`成功复制粘贴数据到PDF 表格中



## 需要继续深入研究的问题

* python 脚本内的程序执行顺序是怎样的? 单线程顺序执行 还是 多线程? 

* python 文件整合? 如何让多个文件之间可以共享信息? 需要一个main file? 

  

## 反思&总结

* 基本原则的应用
  * KISS(Keep It Simple, Stupid) 
    * 先试试用``pyautogui`随便在8949表格里面自动输入两行数据
    * 直接在dataframe中转换, 全部转换好了之后再导出
    * 先全都放在一个python文件里面即可 不需要针对不同的功能进行拆分
  * 不确定的地方直接打印出来
    * dataframe 
* 数据结构很重要 良好的数据结构设计能够帮助 数组是最简单的 但是只能提供按照index下标进行搜索, 而且存的数据必须是用一类型不能够混合比如 String / Int / Object, 而字典可以存复杂的数据类型并且自定义用来被索引的key, 但是需要专门进行字典的构造，并且遍历不太方便，必须要先读到key然后才能提取