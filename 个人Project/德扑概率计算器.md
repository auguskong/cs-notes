##  我的需求
* 根据当前公开的牌 + 手牌来计算出来不同手牌赢得比赛的概率
* 计算当前手牌赢得比赛的不同牌面组合
* 有一个前端UI界面来进行展示









## 前期准备

Udacity 212 课程第一部分是讲这个问题的 可以看一下

https://classroom.udacity.com/courses/cs212/lessons/48688918/concepts/486865220923







## Research



一个可以参考的在线计算器

https://www.cardplayer.com/poker-tools/odds-calculator/texas-holdem



我需要补充的实现

展示能够赢得比赛的牌面



如何通过Chrome Dev Tools 来看到后台JS 的源码? 



需要思考的设计方案: 

1. 用什么数据结构来表示不同选手的手牌，以及还没有发的手牌?

   课程思考题: https://classroom.udacity.com/courses/cs212/lessons/48688918/concepts/486937940923

   ```python
   ['JS', 'JD', '2S', '2C', '7H']
   [(11, 'S'), (11, 'D'), (2, 'S'), (2, 'C'), (7, 'H')]
   set(['JS', 'JD', '2S', '2C', '7H']) # set 会自动过滤重复元素 可能会存在2 deck的游戏 
   "JS JD 2S 2C 7H“ # string type不方便进行单张牌的提取 需要专门进行split
   
   需要结合语言本身的特性以及context两个角度来考虑问题
   ```

   

2. 如何设计赢率的算法?  A: 需要根据德扑的基本计算公式来进行计算?  不同赢牌的牌面应该如何展示?  直接一个HTML tag来展示? 





算法基本流程:

1. 先发牌 每个选手都有两张手牌
2. 剩余的牌需要进行组合 依次来判断 其实就是根据规则来从大到小排列 看一下能够组合出来的  不同组合之间如何进行比较?   这是一个概率问题 概率大小怎么确定? 



`max(hands, key=hand_rank)`: 返回根据`hand_rank`排序得到的max 



```python
print max([3, 4, 5]), max([3, 4, -5, 0], key=abs) #返回 5 -5
```



可以使用`assert()`来进行test



```python
def test():
  "Test cases for the functions in poker program."
  sf = "6C 7C 8C 9C TC".split() # 为什么需要split ? 
  fk = "9D 9H 9S 9C 7D".split()
  fh = "TD TC TH 7C 7D".split()
  assert poker([sf, fk, fh]) == sf
  return "tests pass"
```



If you need a refresher on the rules of poker, check out the [wikipedia article](http://en.wikipedia.org/wiki/List_of_poker_hands) on the ranking of poker hands.



If you are interested in learning more about the **assert** statement, you can read a good discussion on its use [here](http://wiki.python.org/moin/UsingAssertionsEffectively).



Understanding -> Specify -> Design



Testing  



* extream value



Poker 基本术语: 

* hand: 手牌
* rank: 1 2 3 ... J Q K A
* suit: diamond(方块), heart(红桃), spade(黑桃), club(梅花) 
* hand rank: 2 pair, straight
  * n - kind: same kind 相同的数字
  * straight: 顺子
  * flush: 同花



### 知识点

* `index()` function 
* for loop可以同时取出index 和 value



### 代码片段

#### card_ranks

```python
def card_ranks(cards):
    "Return a list of the ranks, sorted with higher first."
    
    ranks = ['--23456789TJQKA'.index(r) for r,s in cards]
    ranks.sort(reverse=True)
    return ranks
    
# 这里只需要考虑rank
print card_ranks(['AC', '3D', '4S', 'KH']) #should output [14, 13, 4, 3]

cards = ['AC', '3D', '4S', 'KH']
for r, s in cards:
	print(r, s)

... 
A C
3 D
4 S
K H
```



#### Straight and Flash



```python

#我的实现
def straight(ranks):
    "Return True if the ordered ranks form a 5-card straight."
    if len(set(ranks)) != len(ranks):
        return False
    ranks.reverse()
    return all(ranks[i] <= ranks[i+1] for i in range(len(ranks)-1))

# Peter的实现 

def straight(ranks):
  	return (max(ranks)-min(ranks) == 4) and len(set(ranks)) == 5
  
def flush(hand):
    "Return True if all the cards have the same suit."
    suit=[s for r,s in hand]
    t = suit[0]
    for sc in suit:
        if sc != t:
            return False
    return True
    
    # Peter的实现
def flush(hand):
  	suits = [s for r, s in hand]
  	return len(set(suits)) == 1

去重操作可以直接通过set()来一步求解

def test():
    "Test cases for the functions in poker program."
    sf = "6C 7C 8C 9C TC".split()
    fk = "9D 9H 9S 9C 7D".split()
    fh = "TD TC TH 7C 7D".split()
    assert straight([9, 8, 7, 6, 5]) == True
    assert straight([9, 8, 8, 6, 5]) == False
    assert flush(sf) == True
    assert flush(fk) == False
    return 'tests pass'
```





#### two_pair

```python

# 我的实现
def two_pair(ranks):
    """If there are two pair, return the two ranks as a
    tuple: (highest, lowest); otherwise return None."""
    # Your code here.
    res = []
    for r in ranks:
        if ranks.count(r) == 2:
            res.append(r)
    res = set(res)
    if len(res) == 0 or len(res) == 1:
        return None
    return tuple(res)
  
# Peter的实现
def two_pair(ranks):
    pair = kind(2, ranks)
    lowpair = kind(2, list(reversed(ranks)))
    if (pair and lowpair != pair):
      	return (pair, lowpair)
    else:
      	return None
```



A 可以作为1来用 组成最小的顺子 需要修改card_ranks的代码 基本原则 如果concept只改了一个地方 那么代码也应该只需要改动一个地方 匹配即可

```python
def card_ranks(cards):
    "Return a list of the ranks, sorted with higher first."
    
    ranks = ['--23456789TJQKA'.index(r) for r,s in cards]
    ranks.sort(reverse=True)
    return ranks
  
# 考虑A作为1的case 
def card_ranks(cards):
    "Return a list of the ranks, sorted with higher first."
    
    ranks = ['--23456789TJQKA'.index(r) for r,s in cards]
    ranks.sort(reverse=True)
    return [5, 4, 3, 2, 1] if (ranks = [14, 5, 4, 3, 2]) else ranks
```



#### allmax 

对于一个不确定是什么类型的数据要如何比较大小呢? 使用传入的key function



```python
# Peter 的实现
def allmax(iterable, key=None):
  result, maxval = [], None
  key = key or (lambda x: x)
  for x in iterable:
    xval = key(x)
    if not result or xval > maxval:
      # 这里是每次发现一个最大值都会overwrite list已经有的值 并更新max value
      result, maxval = [x], xval
    elif xval == maxval:
      result.append(x)
  return result
```

 

#### Deal



```python
# 使用list comprehension 直接组装出来52张card
mydeck = 

def deal(numhands, n=5, deck=[r+s for r in '23456789TJQKA' for s in 'SHDC']):
  random.shuffle(deck)
  # 每n个位一组 直接slice取值即可
  return [deck[n*i:n*(i+1)] for i in range(numhands)]
```





#### Hand Frequencies



```python

def hand_percentages(n=700*1000):
  "Sample n random hands and print a table of percentages for each type of hand"
  counts = [0] * 9
  for i in range(n/10):
    ranking = hand_rank(hand)[0]
    counts[ranking] += 1
  for i in reversed(range(9)):
    # 这里的14是长度 6.3的6是长度 .3是保留的小数点位数 %%是百分号需要转译一下
    print "%14s: %6.3f %%" % (hand_names[i], 100.*counts[i]/n)
    
# 打印结果
Straight Flush:  0.001 %
        4 Kind:  0.019 %
    Full House:  0.146 %
         Flush:  0.198 %
      Straight:  0.401 %
        ...
```



## 心得

 信息其实就是编码 + 上下文的解释 数字可以代表牌的rank 也可以代表不同rank的类型 



straight flash, jack high



<4, 11> 就能直接表示 tuple中可以直接按照顺序 代表的含义不同所以是不能sort的, 第一个数字是代表手牌能够组合的类型, 只有在第一个数字相同的前提下 才需要比较第二个数字



top down 

不断将大问题拆分成不同的小问题 最后只需要实现能够解决小问题的具体算法 模块化/组件化/递归分解 都是类似的思想



Dimensions of Programming 



Program 有过个维度 e.g.  efficiency, features(what does exactly it do), elegance, correctness(基本维度 首先要满足的)

The best is the enemy of the good: 为了追求单一维度上的极致而忽略了其他维度  trade off



如何做Trade off ? 

问自己几个问题: 

1. What do I need most ? 
2. Which direction do I need to mobe? 
3. am I done? Do I not have to move anymore ? 



good is the enemy of great. 

这两个观点是否有点矛盾了呢? 